


#libraries
import turtle
import random
import time
import math
from turtle import *

#borders for later use
RIGHT_EDGE= 400
LEFT_EDGE= -400
BOTTOM_EDGE= -400
TOP_EDGE= 400

#setting screensize and color
screen=Screen()
screen.title=("game window")
screen.bgcolor("black")
turtle.screensize(canvwidth=395,canvheight=395,bg=None) #slightly smaller than the borders so enemies can spawn offscreen
screen.tracer(0) #updates more frequently

    
#setting up the initial player character
player=Turtle()
player.clear()
player.penup()
player.shape("arrow") #arrow will easily show direction facing
player.color("white") #easy to see against a black background
player.shapesize(1,2,1) #sets the size of the player
player.setx(0) #starts in the middle
player.sety(0)

player.setheading(90) #starts facing upward

##########################################################

playerspeed=10 #defining how far the player will move on each keypress

#each of the following functions corresponds to a keypress
def moveright():
    currx=player.xcor() #takes the current position
    player.setx(currx+playerspeed) #moves it a certain amount of units in the chosen direction
    player.setheading(0) #makes the charater face the direction of the keypress

def moveleft():
    currx=player.xcor()
    player.setx(currx-playerspeed)
    player.setheading(180)

def moveup():
    curry=player.ycor()
    player.sety(curry+playerspeed)
    player.setheading(90)

def movedown():
    curry=player.ycor()
    player.sety(curry-playerspeed)
    player.setheading(270)

#defining the onkey presses
turtle.onkey(moveright,"d")
turtle.onkey(moveleft,"a")
turtle.onkey(moveup,"w")
turtle.onkey(movedown,"s")

##########################################################

projectilespeed=8 #setting bullet speed
bulletlist=[] #making a list to move multiple objects at once

def genbullet(): #function for projectile generation
    bulletlist.append(Turtle()) #adds each new item as a turtle to the list
    bulletlist[len(bulletlist)-1].penup() #no trail
    bulletlist[len(bulletlist)-1].shape("circle") #matches color of the player
    bulletlist[len(bulletlist)-1].color("white")
    bulletlist[len(bulletlist)-1].shapesize(0.5,0.5,0.5) #smaller size
    bulletheading=player.heading() #matches position and heading to the player
    bulletx=player.xcor()
    bullety=player.ycor()
    bulletlist[len(bulletlist)-1].setx(bulletx) #moves to match direction player is facing, twice as fast
    bulletlist[len(bulletlist)-1].sety(bullety)
    bulletlist[len(bulletlist)-1].setheading(bulletheading)

#mapped to space
turtle.onkey(genbullet,"space")

##########################################################

global enemyspeed
enemyspeed=0.1
numenemies=1
enemylist=[]
def randy(): #these generate random numbers for spawn coordinates
    randy=random.randint(0,300)
    return(randy)
def randx():
    randx=random.randint(0,300)
    return(randx)
yspawn=300
xspawn=300
def genenemy(numenemies): #generates a set number of enemies based on how many are in the previous loop
    for enemy in range (0,numenemies): #the number of enemies can be easily changed
        enemylist.append(Turtle())
    for enemy in range (0,len(enemylist)):
        enemyx=player.xcor()
        enemyy=player.ycor()
        randyspawn=randy()
        randxspawn=randx()
        enemylist[enemy].penup() #no trail
        enemylist[enemy].shape("square") #different shape and color than player
        enemylist[enemy].color("red")
        enemylist[enemy].shapesize(1,1,1) #smaller size
        enemylist[enemy].setx(randyspawn) #random spawn(s)
        enemylist[enemy].sety(randxspawn)

##########################################################

genenemy(numenemies)
a=0
while True: #goes forever
    a=a+1
    turtle.listen() #waits for keypresses
    screen.update() #updates the screen every loop
    for bullet in range(0,len(bulletlist)): #moves every projectile every loop
        bulletlist[bullet].forward(projectilespeed)
    for enemy in range(0,len(enemylist)):
        if abs(enemylist[enemy-1].xcor()-player.xcor())<=15 and abs(enemylist[enemy-1].ycor()-player.ycor())<=15:
            player.hideturtle()
            del player
            continue
        else:
            pass
        currx=enemylist[enemy-1].xcor() #this whole next section just gets the heading in degrees for the enemies to accurately track the player
        curry=enemylist[enemy-1].ycor()
        enemyx=player.xcor()
        enemyy=player.ycor()
        if enemyx==0:
            enemyx=enemyx+0.5 #cant divide by zero, so this prevents it from being so
        else:
            pass
        if enemyy==0:
            enemyy=enemyy+1
        else:
            pass
        yval=enemyy-curry #finding slope
        xval=enemyx-currx
        slope=yval/xval
        conversion=180/3.141592 #need heading in degrees just to keep everything neat
        enemyheading=math.tan(slope)*conversion+180 #taking the tangent, converting it, and changing it to the opposite direction
        enemylist[enemy-1].setheading(enemyheading) #sets the heading for all the enemies
        enemylist[enemy-1].forward(enemyspeed) #slow for testing
        for bullet in range(0,len(bulletlist)):
            if abs(bulletlist[bullet-1].xcor()-currx)<=10 and abs(bulletlist[bullet-1].ycor()-curry)<=10:
                currx=enemylist[enemy-1].xcor()
                curry=enemylist[enemy-1].ycor()
                bulletlist[bullet-1].hideturtle()
                enemylist[enemy-1].hideturtle()
                del bulletlist[bullet-1]
                del enemylist[enemy-1]
                continue
            else:
                continue
        if bool(enemylist)==False: #checks if the list of enemies is empty
            for x in range(0,3):
                print()
                print("Loading next round",end="")
                for y in range(0,3):
                    print(".",end="")
                    time.sleep(.5)
            rounds += 1
            print()
            print("Round",rounds, "begin") #indicator of new round for testing
            genenemy() #makes a new enemy or enemies
            screen.update() #updates the screen
            #3 seconds in between rounds
            break
        else:
            continue

